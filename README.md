# Сервис курсов валют

Реализация тестового задания

## Постановка
Необходимо реализовать сервис курсов валют на python 3.6+ c использованием фреймворка aoihttp/flask/django.

В базе данных (PostgreSQL/MySQL) Должны быть 2 таблицы:
1. currency с колонками:
	- id
	- name
2. rate с колонками
	- id
	- currency_id
	- date
	- rate (курс валюты к доллару)
	- volume (объем торгов за день)

Реализовать загрузчик курсов в БД. Данные по курсам брать с биржи bitfinex(https://docs.bitfinex.com/reference#rest-public-candles)

Например:

    curl https://api-pub.bitfinex.com/v2/candles/trade:1D:tBTCUSD/hist
    curl https://api-pub.bitfinex.com/v2/candles/trade:1D:tETHUSD/hist
    curl https://api-pub.bitfinex.com/v2/candles/trade:1D:tXPRUSD/hist

Нас интересуют поля CLOSE и VOLUME
Количество валют не менее 5, курсы за последние 10 дней

Реализовать 2 REST Api метода:
1. GET /currencies - список валют с поддержкой пагинации
2. GET /rate/ - должен возвращать последний курс валюты, для переданного id, а также средний объем торгов за последние 10 дней

API должно быть закрыто Basic авторизацией

Не забудьте описать зависимости в pip-requirements.txt


## Установка и запуск

### Через docker
Нужно в корне проекта выполнить комманду:
` docker-compose up --build -d`

Поднятое API будет доступно локально по порту **5002**

Так же можно в `.env` файле задать переменную среды **TZ**. Скорее всего без неё расхождение в часовых поясах приведёт к ошибкам в работе API.

Например:
`TZ=Asia/Tashkent`


### Локально без докера
1. Требуется **python3.6+** и установщик **pip**
2. В корне проекта выполнить `pip install -r requirements.txt`
3. В файле config.py указать в переменной **SQLALCHEMY_DATABASE_URI**  путь к sqlite или mysql бд
4. выполнить `python launch_app.py`

## Общее описание реализации
Приложение написано на **Flask** и запускается на **waitress**. Отдельным тредом запускается **grabber**. С определённой переодичностью граббер собирает данные по курсам валют, которые хранятся в БД.

Т.к. часовой пояс клиента и сервера bitfinex различаются, то прямой запрос статистики за последние 10 дней с размером фрейма в 1 день (frame - параметр api) даст неточные результат. Поэтому граббер запрашивает данные в часах, а не в днях и группирует их по дням исходя из своего часового пояса. Поэтому данные запрошенные за 10 дней - это реально статистика за 10 дней по вашему часовому поясу.

Приложение расчитано на работу с пустой бд, с пустыми таблицами или с непустыми таблицами, которые находятся в корректном состоянии.
Корректное состояние БД, это когда нет currency_id,  указывающих на несущществующие валюты, и данные не старше 10ти дней являются непрерывными - т.е. содержат подряд все дни. К примеру, если младшая запись 5ти днейвной давности, а старшая 10-ти, то должны быть все записи в промежутки с 5-ти до 10-ти дневной давности. Данные старше 10 дней могут быть сколько угодно обрывистыми.

При запуске граббер старается инициализировать БД и таблицы в ней. API и граббер так же можно отключить и включить снова. Тогда граббер продолжит сбор данных, без затирания уже существующей информации.

### Настройки
В `config.py` находятся боевые настройки. А именно:
- **DEBUG (bool)**: включить режим отладки
- **DISABLE_AUTH (bool)**: убрать аутентефикацию (только при отладке)
- **TARGET_CURRENCY(str(3))**: Валюта по отношению которой собираются данные курсов
- **NO_BACKGROUND (bool**): Запредить запускать grabber в виде отдельного треда. Обновление курсов валют происходит теперь только при вызове `POST /ratesgrabber`.(только при отладке)
- **DEPTH(int)**: глубина анализа в днях
- **API_TRADE_URL(str)**: путь к trade Api
- **RATES_UPDATES_DELAY(int)**: перерыв между вызовами граббера в секундах
- **SQLALCHEMY_DATABASE_URI(str)**: uri к базе данных

Аналогичные настройки задаются в файле `config_for_tests.py`
В этом файле хранятся настройки для авто тестов. Изменение этих параметров приведёт к поломке авто тестов.


### Автотесты
Для юнит тестов используется **pytests**. Юнит тестами покрыты **Api** и **grabber** модуль.
Для поведенчиских тестов используется **behave**. BDD тестирует совместную работу **Api** и **grabber**, также парочку простых сценариев совместной работы.


## API

### Модели

#### Currency
Модель, описывающая валюту

Поля:
- **id [int]:** id номер валюты
- **name [str(3)]:** наименование валюты

#### CurrencyStat
Модель, описывающая статистику валюты за последние N дней

Поля:
- **rate [float]:** последнее известное значение курса валюты
- **average_by_day [float]:** средний объем продаж за N дней
- **depth [int]:** количество последних N дней за которое была собрана статистика

#### Message
Модель, описывающщее сообщение ошибки или отладочной информации

Поля:
- **message [string]:** сообщение


### Запросы
Все запросы принимают и отдают json объекты моделей.
Запросы закрыты BasicAuth авторизацией.

Логин/Пароль: *admin/iddqd*

#### /currencies
- **GET:** получить список моделей *Currency*. Поддерживаются параметры *page* и *per_page* для пагинации
- **POST:** Добавляет новую валюту. Принимает модель *Currency* без поля `id`. Возвращает 201 в случае успеха и модель *Currency*  с присвоенным id

#### /currency/{currency id}
- **GET:** получить модель *Currency* по её id.
- **DELETE:** Удалить модель *Currency* по её id. Возвращает 204 в случае успеха

#### /rate/{currency id}
- **GET:** получить модель *CurrencyStat* по id валюты.

#### /ratesgrabber
- **POST:** Заставить граббер прямо сейчас обновить курсы валют. Запрос доступен только в режиме отладки. Возвращает в случае успеха код 200 модель Message со служебным сообщением.


## Улучшения
Разумеется, в рамках тестового задания и для демонстрации своих умений здесь можно очень многое добавить и улучшить. К примеру не хранить в переменной логин и пароль (использовать БД для учетных записей), использовать хеш суммы для паролей, вынести в переменные окружения параметры подключения к БД (это позволило бы запустить контейнер API для работы с указанной БД) и т.д.
Если этих решений здесь нет - это не значит, что я не умею. Это значит, что я не посчитал нужным настолько далеко заходить в написании простого тестового задания.
